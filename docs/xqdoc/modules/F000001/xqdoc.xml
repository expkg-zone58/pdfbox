<xqdoc:xqdoc xmlns:xqdoc="http://www.xqdoc.org/1.0"><xqdoc:control><xqdoc:date>2025-06-04T16:17:13.527+01:00</xqdoc:date><xqdoc:version>1.1</xqdoc:version></xqdoc:control><xqdoc:module type="library"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>pdfbox</xqdoc:name><xqdoc:comment><xqdoc:description>&#xD;
&#xD;
A BaseX 10.7+ interface to pdfbox3 https://pdfbox.apache.org/ ,&#xD;
requires pdfbox jars on classpath, in lib/custom or xar&#xD;
refer to the same concept. Also label and (page)range are used interchangably&#xD;
</xqdoc:description><xqdoc:author>Andy Bunce 2025</xqdoc:author><xqdoc:see>https://pdfbox.apache.org/download.cgi</xqdoc:see><xqdoc:custom tag="note">following the java source the terms outline and bookmark</xqdoc:custom><xqdoc:custom tag="note">tested with pdfbox-app-3.0.5.jar</xqdoc:custom><xqdoc:custom tag="javadoc">https://javadoc.io/static/org.apache.pdfbox/pdfbox/3.0.5/</xqdoc:custom></xqdoc:comment><xqdoc:body>xquery version '3.1';&#xD;
(:~ &#xD;
A BaseX 10.7+ interface to pdfbox3 https://pdfbox.apache.org/ , &#xD;
requires pdfbox jars on classpath, in lib/custom or xar&#xD;
@note following the java source the terms outline and bookmark&#xD;
refer to the same concept. Also label and (page)range are used interchangably&#xD;
@note tested with pdfbox-app-3.0.5.jar&#xD;
@see https://pdfbox.apache.org/download.cgi&#xD;
@javadoc https://javadoc.io/static/org.apache.pdfbox/pdfbox/3.0.5/&#xD;
@author Andy Bunce 2025&#xD;
:)&#xD;
&#xD;
module namespace pdfbox="org.expkg_zone58.Pdfbox3";&#xD;
&#xD;
declare namespace Loader ="java:org.apache.pdfbox.Loader"; &#xD;
declare namespace PDFTextStripper = "java:org.apache.pdfbox.text.PDFTextStripper";&#xD;
declare namespace PDDocument ="java:org.apache.pdfbox.pdmodel.PDDocument";&#xD;
declare namespace PDDocumentCatalog ="java:org.apache.pdfbox.pdmodel.PDDocumentCatalog";&#xD;
declare namespace PDPageLabels ="java:org.apache.pdfbox.pdmodel.common.PDPageLabels";&#xD;
declare namespace PDPageLabelRange="java:org.apache.pdfbox.pdmodel.common.PDPageLabelRange";&#xD;
&#xD;
declare namespace PageExtractor ="java:org.apache.pdfbox.multipdf.PageExtractor";&#xD;
declare namespace PDPage ="java:org.apache.pdfbox.pdmodel.PDPage";&#xD;
declare namespace PDPageTree ="java:org.apache.pdfbox.pdmodel.PDPageTree";&#xD;
declare namespace PDDocumentOutline ="java:org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDDocumentOutline";&#xD;
declare namespace PDDocumentInformation ="java:org.apache.pdfbox.pdmodel.PDDocumentInformation";&#xD;
declare namespace PDOutlineItem="java:org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem";&#xD;
declare namespace PDFRenderer="java:org.apache.pdfbox.rendering.PDFRenderer";&#xD;
declare namespace PDMetadata="java:org.apache.pdfbox.pdmodel.common.PDMetadata";&#xD;
declare namespace COSInputStream="java:org.apache.pdfbox.cos.COSInputStream";&#xD;
&#xD;
&#xD;
declare namespace rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#";&#xD;
&#xD;
&#xD;
declare namespace RandomAccessReadBuffer="java:org.apache.pdfbox.io.RandomAccessReadBuffer";&#xD;
declare namespace RandomAccessReadBufferedFile = "java:org.apache.pdfbox.io.RandomAccessReadBufferedFile";&#xD;
declare namespace PDRectangle="org.apache.pdfbox.pdmodel.common.PDRectangle";&#xD;
&#xD;
declare namespace File ="java:java.io.File";&#xD;
&#xD;
&#xD;
&#xD;
(:~ "With-document" pattern: open pdf,apply $fn function, close pdf&#xD;
 creates a local pdfobject and ensures it is closed after use&#xD;
e.g pdfbox:with-pdf("path...",pdfbox:page-text(?,5))&#xD;
:)&#xD;
declare function pdfbox:with-pdf($src as xs:string,&#xD;
                                $fn as function(item())as item()*)&#xD;
as item()*{&#xD;
 let $pdf:=pdfbox:open($src)&#xD;
 return try{&#xD;
            $fn($pdf),pdfbox:close($pdf)&#xD;
        } catch *{&#xD;
            pdfbox:close($pdf),fn:error($err:code,$src || " " || $err:description)&#xD;
        }&#xD;
&#xD;
};&#xD;
&#xD;
&#xD;
(:~ open pdf using fetch:binary, returns pdf object :)&#xD;
declare function pdfbox:open($pdfsrc as item())&#xD;
as item(){&#xD;
pdfbox:open($pdfsrc, map{})&#xD;
};&#xD;
&#xD;
(:~ open pdf from file/url/binary, opts may have password , returns pdf object &#xD;
@param $pdfsrc a fetchable url or filepath, or xs:base64Binary item&#xD;
@param $opts options options include map {"password":}&#xD;
@note fetch:binary for https will use a lot of memory here&#xD;
:)&#xD;
declare function pdfbox:open($pdfsrc as item(), $opts as map(*))&#xD;
as item(){&#xD;
  try{&#xD;
&#xD;
      if($pdfsrc instance of xs:base64Binary)&#xD;
      then Loader:loadPDF( $pdfsrc,string($opts?password))&#xD;
      else if(starts-with($pdfsrc,"http"))&#xD;
           then Loader:loadPDF( fetch:binary($pdfsrc),string($opts?password))&#xD;
           else  Loader:loadPDF(RandomAccessReadBufferedFile:new($pdfsrc),string($opts?password))&#xD;
&#xD;
} catch *{&#xD;
    let $loc:=if($pdfsrc instance of xs:base64Binary)&#xD;
              then "xs:base64Binary"&#xD;
              else $pdfsrc&#xD;
    return error(xs:QName("pdfbox:open"),"Failed PDF load " || $loc || " " || $err:description)&#xD;
}&#xD;
};&#xD;
&#xD;
(:~ The version of the PDF specification used by $pdf  e.g "1.4"&#xD;
returned as string to avoid float rounding issues&#xD;
 :)&#xD;
declare function pdfbox:specification($pdf as item())&#xD;
as xs:string{&#xD;
 PDDocument:getVersion($pdf)=&gt;xs:decimal()=&gt;round(4)=&gt;string()&#xD;
};&#xD;
&#xD;
(:~ Save pdf $pdf to filesystem at $savepath , returns $savepath :)&#xD;
declare function pdfbox:pdf-save($pdf as item(),$savepath as xs:string)&#xD;
as xs:string{&#xD;
   PDDocument:save($pdf, File:new($savepath)),$savepath&#xD;
};&#xD;
&#xD;
(:~ Create binary representation of $pdf object as xs:base64Binary :)&#xD;
declare function pdfbox:binary($pdf as item())&#xD;
as xs:base64Binary{&#xD;
   let $bytes:=Q{java:java.io.ByteArrayOutputStream}new()&#xD;
   let $_:=PDDocument:save($pdf, $bytes)&#xD;
   return  Q{java:java.io.ByteArrayOutputStream}toByteArray($bytes)&#xD;
         =&gt;convert:integers-to-base64()&#xD;
};&#xD;
&#xD;
(:~ Release any resources related to $pdf:)&#xD;
declare function pdfbox:close($pdf as item())&#xD;
as empty-sequence(){&#xD;
  (# db:wrapjava void #) {&#xD;
     PDDocument:close($pdf)&#xD;
  }&#xD;
};&#xD;
&#xD;
(:~ Number of pages in PDF:)&#xD;
declare function pdfbox:number-of-pages($pdf as item())&#xD;
as xs:integer{&#xD;
  PDDocument:getNumberOfPages($pdf)&#xD;
};&#xD;
&#xD;
(:~ Pdf page as image (zero is cover)&#xD;
options.format="bmp jpg png gif" etc, options.scale= 1 is 72 dpi?? :)&#xD;
declare function pdfbox:page-render($pdf as item(),$pageNo as xs:integer,$options as map(*))&#xD;
as xs:base64Binary{&#xD;
  let $options := map:merge(($options,map{"format":"jpg","scale":1}))&#xD;
  let $bufferedImage := PDFRenderer:new($pdf)&#xD;
                      =&gt;PDFRenderer:renderImage($pageNo,$options?scale)&#xD;
  let $bytes := Q{java:java.io.ByteArrayOutputStream}new()&#xD;
  let $_ := Q{java:javax.imageio.ImageIO}write($bufferedImage ,$options?format,  $bytes)&#xD;
  return Q{java:java.io.ByteArrayOutputStream}toByteArray($bytes)&#xD;
         =&gt;convert:integers-to-base64()&#xD;
 &#xD;
};&#xD;
&#xD;
&#xD;
(:~ Defines a map from property names to evaluation method.&#xD;
   Keys are property names, &#xD;
   values are sequences of functions to get property value starting from a $pdf object.&#xD;
:)&#xD;
declare %private variable $pdfbox:property-map:=map{&#xD;
  "#pages": pdfbox:number-of-pages#1,&#xD;
&#xD;
  "#bookmarks": pdfbox:number-of-bookmarks#1,&#xD;
&#xD;
  "#labels": pdfbox:number-of-labels#1,&#xD;
&#xD;
  "specification":pdfbox:specification#1,&#xD;
&#xD;
  "title": (PDDocument:getDocumentInformation#1,&#xD;
            PDDocumentInformation:getTitle#1) ,&#xD;
&#xD;
  "author": (PDDocument:getDocumentInformation#1,&#xD;
             PDDocumentInformation:getAuthor#1 ),&#xD;
&#xD;
  "creator": (PDDocument:getDocumentInformation#1,&#xD;
              PDDocumentInformation:getCreator#1),&#xD;
&#xD;
  "producer": (PDDocument:getDocumentInformation#1,&#xD;
               PDDocumentInformation:getProducer#1),&#xD;
&#xD;
  "subject": (PDDocument:getDocumentInformation#1,&#xD;
              PDDocumentInformation:getSubject#1),&#xD;
&#xD;
  "keywords": (PDDocument:getDocumentInformation#1,&#xD;
               PDDocumentInformation:getKeywords#1),&#xD;
&#xD;
  "creationDate": (PDDocument:getDocumentInformation#1,&#xD;
                   PDDocumentInformation:getCreationDate#1,&#xD;
                   pdfbox:gregToISO#1),&#xD;
&#xD;
  "modificationDate":  (PDDocument:getDocumentInformation#1,&#xD;
                        PDDocumentInformation:getModificationDate#1,&#xD;
                        pdfbox:gregToISO#1),&#xD;
&#xD;
   "labels":      pdfbox:labels-as-string#1                     &#xD;
};&#xD;
&#xD;
(:~ Defined property names, sorted :)&#xD;
declare function pdfbox:property-names() &#xD;
as xs:string*{&#xD;
  $pdfbox:property-map=&gt;map:keys()=&gt;sort()&#xD;
};&#xD;
&#xD;
(:~  Return the value of $property for $pdf :)&#xD;
declare function pdfbox:property($pdf as item(),$property as xs:string)&#xD;
as item()*{&#xD;
  let $fns:= $pdfbox:property-map($property)&#xD;
  return if(exists($fns))&#xD;
         then fold-left($fns, &#xD;
                        $pdf, &#xD;
                        function($result,$this as function(*)){$result!$this(.)})&#xD;
         else error(xs:QName('pdfbox:property'),concat("Property '",$property,"' not defined."))&#xD;
};&#xD;
&#xD;
(:~ summary CSV style info for all properties for $pdfpaths &#xD;
:)&#xD;
declare function pdfbox:report($pdfpaths as xs:string*)&#xD;
as map(*){&#xD;
 pdfbox:report($pdfpaths,pdfbox:property-names())&#xD;
};&#xD;
&#xD;
(:~ summary CSV style info for named $properties for PDFs in $pdfpaths &#xD;
@see https://docs.basex.org/main/CSV_Functions#xquery&#xD;
:)&#xD;
declare function pdfbox:report($pdfpaths as item()*, $properties as xs:string*)&#xD;
as map(*){&#xD;
  map{"names":   array{"path",$properties},&#xD;
  &#xD;
      "records": for $path in $pdfpaths&#xD;
                 let $name:=if($path instance of xs:base64Binary) then "binary" else $path&#xD;
                 return try{&#xD;
                  let $pdf:=pdfbox:open($path)&#xD;
                  return (fold-left($properties,&#xD;
                                  array{$name},&#xD;
                                  function($result as array(*),$prop as xs:string){&#xD;
                                    array:append($result, string(pdfbox:property($pdf, $prop)))}&#xD;
                         ), pdfbox:close($pdf)&#xD;
                         )&#xD;
                 } catch *{&#xD;
                      fold-left($properties,&#xD;
                                array{$name},&#xD;
                                function($result as array(*),$prop as xs:string){&#xD;
                                    array:append($result, "#ERROR")}&#xD;
                               )&#xD;
                 }&#xD;
               &#xD;
  }&#xD;
};&#xD;
&#xD;
(:~ Convenience function to save report() data to file :)&#xD;
declare function pdfbox:report-save($data as map(*),$dest as xs:string)&#xD;
as empty-sequence(){&#xD;
  let $opts := map {  "format":"xquery", "header":"yes", "separator" : "," }&#xD;
  return file:write-text($dest,csv:serialize($data,$opts))&#xD;
};&#xD;
&#xD;
(:~ The number of outline items defined in $pdf :)&#xD;
declare function pdfbox:number-of-bookmarks($pdf as item())&#xD;
as xs:integer{&#xD;
  let $xml:=pdfbox:outline-xml($pdf)&#xD;
  return count($xml//bookmark)&#xD;
};&#xD;
&#xD;
(:~ XMP metadata as "RDF" document&#xD;
@note usually rdf:RDF root, but sometimes x:xmpmeta &#xD;
:)&#xD;
declare function pdfbox:metadata($pdf as item())&#xD;
as document-node(element(*))?&#xD;
{&#xD;
  let $m:=PDDocument:getDocumentCatalog($pdf)&#xD;
         =&gt;PDDocumentCatalog:getMetadata()&#xD;
  return  if(exists($m))&#xD;
          then &#xD;
              let $is:=PDMetadata:exportXMPMetadata($m)&#xD;
              return pdfbox:do-until(&#xD;
                        map{"n":0,"data":""},&#xD;
&#xD;
                        function($input,$pos ) {  pdfbox:read-stream($is,$input?data)},&#xD;
&#xD;
                        function($output,$pos) { $output?n eq -1 }     &#xD;
                     )?data=&gt;parse-xml()&#xD;
          else ()&#xD;
};&#xD;
&#xD;
(:~ read next block from XMP stream :)&#xD;
declare %private function pdfbox:read-stream($is,$read as xs:string)&#xD;
as map(*){&#xD;
  let $blen:=4096&#xD;
  let $buff:=Q{java:java.util.Arrays}copyOf(array{xs:byte(0)},$blen)&#xD;
  let $n:= COSInputStream:read($is,$buff,xs:int(0),xs:int($blen))&#xD;
  let $data:=convert:integers-to-base64(subsequence($buff,1,$n))=&gt;convert:binary-to-string()&#xD;
  return map{"n":$n, "data": $read || $data}&#xD;
};&#xD;
&#xD;
(:~ Return outline for $pdf as map()* :)&#xD;
declare function pdfbox:outline($pdf as item())&#xD;
as map(*)*{&#xD;
  (# db:wrapjava some #) {&#xD;
  let $outline:=&#xD;
                PDDocument:getDocumentCatalog($pdf)&#xD;
                =&gt;PDDocumentCatalog:getDocumentOutline()&#xD;
 &#xD;
  return  if(exists($outline))&#xD;
          then pdfbox:outline($pdf,PDOutlineItem:getFirstChild($outline)) &#xD;
  }&#xD;
};&#xD;
&#xD;
(:~ return bookmark info for children of $outlineItem as seq of maps :)&#xD;
declare %private function pdfbox:outline($pdf as item(),$outlineItem as item()?)&#xD;
as map(*)*{&#xD;
  let $find as map(*):=pdfbox:outline_($pdf ,$outlineItem)&#xD;
  return map:get($find,"list")&#xD;
};&#xD;
&#xD;
(:~ outline helper. BaseX bug 10.7? error if inlined in outline :)&#xD;
declare %private function pdfbox:outline_($pdf as item(),$outlineItem as item()?)&#xD;
as map(*){&#xD;
  pdfbox:do-until(&#xD;
    &#xD;
     map{"list":(),"this":$outlineItem},&#xD;
&#xD;
     function($input,$pos ) { &#xD;
        let $bk:= pdfbox:bookmark($input?this,$pdf)&#xD;
        let $bk:= if($bk?hasChildren)&#xD;
                  then let $kids:=pdfbox:outline($pdf,PDOutlineItem:getFirstChild($input?this))&#xD;
                        return map:merge(($bk,map:entry("children",$kids)))&#xD;
                  else $bk &#xD;
        return map{&#xD;
              "list": ($input?list, $bk),&#xD;
              "this":  PDOutlineItem:getNextSibling($input?this)}&#xD;
      },&#xD;
&#xD;
     function($output,$pos) { empty($output?this) }                      &#xD;
  )&#xD;
};&#xD;
&#xD;
(:~ PDF outline in xml format :)&#xD;
declare function pdfbox:outline-xml($pdf as item())&#xD;
as element(outline)?{&#xD;
 let $outline:=pdfbox:outline($pdf)&#xD;
  return if(exists($outline))&#xD;
         then &lt;outline&gt;{$outline!pdfbox:bookmark-xml(.)}&lt;/outline&gt;&#xD;
         else ()&#xD;
};&#xD;
&#xD;
(:~ Convert outline map to XML :)&#xD;
declare %private function pdfbox:bookmark-xml($outline as map(*)*)&#xD;
as element(bookmark)*&#xD;
{&#xD;
  $outline!&#xD;
  &lt;bookmark title="{?title}" index="{?index}"&gt;&#xD;
    {?children!pdfbox:bookmark-xml(.)}&#xD;
  &lt;/bookmark&gt;&#xD;
};&#xD;
&#xD;
(:~ Return bookmark info for $bookmark&#xD;
@return map{index:..,title:..,hasChildren:..}&#xD;
:)&#xD;
declare %private function pdfbox:bookmark($bookmark as item(),$pdf as item())&#xD;
as map(*)&#xD;
{&#xD;
 map{ &#xD;
  "index":  PDOutlineItem:findDestinationPage($bookmark,$pdf)=&gt;pdfbox:find-page($pdf),&#xD;
  "title":  (# db:checkstrings #) {PDOutlineItem:getTitle($bookmark)}&#xD;
  (:=&gt;translate("ï¿½",""), :),&#xD;
  "hasChildren": PDOutlineItem:hasChildren($bookmark)&#xD;
  }&#xD;
};&#xD;
&#xD;
&#xD;
(:~ pageIndex of $page in $pdf :)&#xD;
declare function pdfbox:find-page(&#xD;
   $page as item()? (: as java:org.apache.pdfbox.pdmodel.PDPage :),&#xD;
   $pdf as item())&#xD;
as item()?&#xD;
{&#xD;
  if(exists($page))&#xD;
  then PDDocument:getDocumentCatalog($pdf)&#xD;
      =&gt;PDDocumentCatalog:getPages()&#xD;
      =&gt;PDPageTree:indexOf($page)&#xD;
};            &#xD;
&#xD;
(:~  Return new  PDF doc with pages from $start to $end as xs:base64Binary, (1 based)  &#xD;
@param $start first page to include&#xD;
@param $end last page to include&#xD;
:)&#xD;
declare function pdfbox:extract-range($pdf as item(), &#xD;
             $start as xs:integer,$end as xs:integer)&#xD;
as xs:base64Binary&#xD;
{&#xD;
    let $a:=PageExtractor:new($pdf, $start, $end) =&gt;PageExtractor:extract()&#xD;
    return (pdfbox:binary($a),pdfbox:close($a)) &#xD;
};&#xD;
&#xD;
(:~ The number of labels defined in PDF  :)&#xD;
declare function pdfbox:number-of-labels($pdf as item())&#xD;
as xs:integer&#xD;
{&#xD;
  let $labels:=PDDocument:getDocumentCatalog($pdf)&#xD;
               =&gt;PDDocumentCatalog:getPageLabels()&#xD;
  return if(exists($labels)) &#xD;
         then PDPageLabels:getPageRangeCount($labels)&#xD;
         else 0&#xD;
};&#xD;
&#xD;
(:~   pageLabel for every page from derived from page-ranges&#xD;
The returned sequence will contain at MOST as much entries as the document has pages.&#xD;
@see https://www.w3.org/TR/WCAG20-TECHS/PDF17.html#PDF17-examples&#xD;
@see https://codereview.stackexchange.com/questions/286078/java-code-showing-page-labels-from-pdf-files&#xD;
:)&#xD;
declare function pdfbox:labels-by-page($pdf as item())&#xD;
as xs:string*&#xD;
{&#xD;
  PDDocument:getDocumentCatalog($pdf)&#xD;
  =&gt;PDDocumentCatalog:getPageLabels()&#xD;
  =&gt;PDPageLabels:getLabelsByPageIndices()&#xD;
};&#xD;
&#xD;
(:~ sequence of label ranges defined in PDF as formatted strings&#xD;
@return a custom representation of the labels e.g "0-*Cover,1r,11D" &#xD;
:)&#xD;
declare function pdfbox:labels-as-string($pdf as item())&#xD;
as xs:string{&#xD;
  let $pagelabels:=PDDocument:getDocumentCatalog($pdf)&#xD;
                   =&gt;PDDocumentCatalog:getPageLabels()&#xD;
  return $pagelabels&#xD;
         !(0 to pdfbox:number-of-pages($pdf)-1)&#xD;
         !pdfbox:label-as-string($pagelabels,.)=&gt;string-join("&amp;#10;")&#xD;
            &#xD;
};&#xD;
&#xD;
(:~ get pagelabels exist :)&#xD;
declare function pdfbox:page-labels($pdf)&#xD;
{&#xD;
  PDDocument:getDocumentCatalog($pdf)&#xD;
  =&gt;PDDocumentCatalog:getPageLabels()&#xD;
};&#xD;
&#xD;
(:~ label for $page formated as string, empty if none :)&#xD;
declare function pdfbox:label-as-string($pagelabels,$page as  xs:integer)&#xD;
as xs:string?{&#xD;
  let $label:=PDPageLabels:getPageLabelRange($pagelabels,$page)&#xD;
  return  if(empty($label))&#xD;
          then ()&#xD;
          else&#xD;
            let $start:=  PDPageLabelRange:getStart($label)&#xD;
            let $style := PDPageLabelRange:getStyle($label)&#xD;
            let $prefix:= PDPageLabelRange:getPrefix($label) &#xD;
            return string-join(($page, &#xD;
                                if(empty($style)) then "-" else $style,&#xD;
                                if(($start eq 1)) then "" else $start,&#xD;
                                if(exists($prefix)) then '*' || $prefix  (:TODO double " :)&#xD;
                    ))&#xD;
};&#xD;
&#xD;
(:~ sequence of maps for each label/page range defined in $pdf:)&#xD;
declare function pdfbox:labels-as-map($pdf as item())&#xD;
as map(*)*{&#xD;
  let $pagelabels:=PDDocument:getDocumentCatalog($pdf)&#xD;
                   =&gt;PDDocumentCatalog:getPageLabels()&#xD;
  return  $pagelabels&#xD;
          !(0 to pdfbox:number-of-pages($pdf)-1)&#xD;
          !pdfbox:label-as-map($pagelabels,.)&#xD;
};&#xD;
&#xD;
(:~ label/page-range for $page as map :)&#xD;
declare function pdfbox:label-as-map($pagelabels,$page as  xs:integer)&#xD;
as map(*)&#xD;
{&#xD;
  let $label:=PDPageLabels:getPageLabelRange($pagelabels,$page)&#xD;
  return if(empty($label))&#xD;
  then ()&#xD;
  else map{&#xD;
      "index": $page,&#xD;
      "prefix": PDPageLabelRange:getPrefix($label),&#xD;
      "start":  PDPageLabelRange:getStart($label),&#xD;
      "style":  PDPageLabelRange:getStyle($label)&#xD;
      }&#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
(:~ return text on $pageNo :)&#xD;
declare function pdfbox:page-text($pdf as item(), $pageNo as xs:integer)&#xD;
as xs:string{&#xD;
  let $tStripper := (# db:wrapjava instance #) {&#xD;
         PDFTextStripper:new()&#xD;
         =&gt; PDFTextStripper:setStartPage($pageNo)&#xD;
         =&gt; PDFTextStripper:setEndPage($pageNo)&#xD;
       }&#xD;
  return (# db:checkstrings #) {PDFTextStripper:getText($tStripper,$pdf)}&#xD;
};&#xD;
&#xD;
(:~ Return size of $pageNo (zero based)&#xD;
@return e.g. [0.0,0.0,168.0,239.52]&#xD;
 :)&#xD;
declare function pdfbox:page-media-box($pdf as item(), $pageNo as xs:integer)&#xD;
as xs:string{&#xD;
  PDDocument:getPage($pdf, $pageNo)&#xD;
  =&gt;PDPage:getMediaBox()&#xD;
  =&gt;PDRectangle:toString()&#xD;
};&#xD;
&#xD;
(:~  Version of Apache Pdfbox in use  e.g. "3.0.4" :)&#xD;
declare function pdfbox:version()&#xD;
as xs:string{&#xD;
  Q{java:org.apache.pdfbox.util.Version}getVersion()&#xD;
};&#xD;
&#xD;
(:~ Convert date :)&#xD;
declare %private&#xD;
function pdfbox:gregToISO($item as item()?)&#xD;
as xs:string?{&#xD;
 if(exists($item))&#xD;
 then Q{java:java.util.GregorianCalendar}toZonedDateTime($item)=&gt;string()&#xD;
 else ()&#xD;
};&#xD;
&#xD;
(:~ fn:do-until shim for BaseX 9+10 &#xD;
if  fn:do-until not found use hof:until, note: $pos always zero&#xD;
:)&#xD;
declare %private function pdfbox:do-until(&#xD;
 $input 	as item()*, 	&#xD;
 $action 	as function(item()*, xs:integer) as item()*, 	&#xD;
 $predicate 	as function(item()*, xs:integer) as xs:boolean? 	&#xD;
) as item()*&#xD;
{&#xD;
  let $fn:=function-lookup(QName('http://www.w3.org/2005/xpath-functions','do-until'), 3)&#xD;
  return if(exists($fn))&#xD;
         then $fn($input,$action,$predicate)&#xD;
         else let $hof:=function-lookup(QName('http://basex.org/modules/hof','until'), 3)&#xD;
              return if(exists($hof))&#xD;
                      then $hof($predicate(?,0),$action(?,0),$input)&#xD;
                      else error(xs:QName('pdfbox:do-until'),"No implementation do-until found")&#xD;
&#xD;
};&#xD;
</xqdoc:body></xqdoc:module><xqdoc:namespaces><xqdoc:namespace prefix="pdfbox" uri="org.expkg_zone58.Pdfbox3"/><xqdoc:namespace prefix="Loader" uri="java:org.apache.pdfbox.Loader"/><xqdoc:namespace prefix="PDFTextStripper" uri="java:org.apache.pdfbox.text.PDFTextStripper"/><xqdoc:namespace prefix="PDDocument" uri="java:org.apache.pdfbox.pdmodel.PDDocument"/><xqdoc:namespace prefix="PDDocumentCatalog" uri="java:org.apache.pdfbox.pdmodel.PDDocumentCatalog"/><xqdoc:namespace prefix="PDPageLabels" uri="java:org.apache.pdfbox.pdmodel.common.PDPageLabels"/><xqdoc:namespace prefix="PDPageLabelRange" uri="java:org.apache.pdfbox.pdmodel.common.PDPageLabelRange"/><xqdoc:namespace prefix="PageExtractor" uri="java:org.apache.pdfbox.multipdf.PageExtractor"/><xqdoc:namespace prefix="PDPage" uri="java:org.apache.pdfbox.pdmodel.PDPage"/><xqdoc:namespace prefix="PDPageTree" uri="java:org.apache.pdfbox.pdmodel.PDPageTree"/><xqdoc:namespace prefix="PDDocumentOutline" uri="java:org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDDocumentOutline"/><xqdoc:namespace prefix="PDDocumentInformation" uri="java:org.apache.pdfbox.pdmodel.PDDocumentInformation"/><xqdoc:namespace prefix="PDOutlineItem" uri="java:org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem"/><xqdoc:namespace prefix="PDFRenderer" uri="java:org.apache.pdfbox.rendering.PDFRenderer"/><xqdoc:namespace prefix="PDMetadata" uri="java:org.apache.pdfbox.pdmodel.common.PDMetadata"/><xqdoc:namespace prefix="COSInputStream" uri="java:org.apache.pdfbox.cos.COSInputStream"/><xqdoc:namespace prefix="rdf" uri="http://www.w3.org/1999/02/22-rdf-syntax-ns#"/><xqdoc:namespace prefix="RandomAccessReadBuffer" uri="java:org.apache.pdfbox.io.RandomAccessReadBuffer"/><xqdoc:namespace prefix="RandomAccessReadBufferedFile" uri="java:org.apache.pdfbox.io.RandomAccessReadBufferedFile"/><xqdoc:namespace prefix="PDRectangle" uri="org.apache.pdfbox.pdmodel.common.PDRectangle"/><xqdoc:namespace prefix="File" uri="java:java.io.File"/><xqdoc:namespace prefix="xs" uri="http://www.w3.org/2001/XMLSchema"/><xqdoc:namespace prefix="fn" uri="http://www.w3.org/2005/xpath-functions"/><xqdoc:namespace prefix="err" uri="http://www.w3.org/2005/xqt-errors"/><xqdoc:namespace prefix="fetch" uri="http://basex.org/modules/fetch"/><xqdoc:namespace prefix="convert" uri="http://basex.org/modules/convert"/><xqdoc:namespace prefix="db" uri="http://basex.org/modules/db"/><xqdoc:namespace prefix="map" uri="http://www.w3.org/2005/xpath-functions/map"/><xqdoc:namespace prefix="array" uri="http://www.w3.org/2005/xpath-functions/array"/><xqdoc:namespace prefix="file" uri="http://expath.org/ns/file"/><xqdoc:namespace prefix="csv" uri="http://basex.org/modules/csv"/></xqdoc:namespaces><xqdoc:variables><xqdoc:variable><xqdoc:name>pdfbox:property-map</xqdoc:name><xqdoc:comment><xqdoc:description>&#xD;
Defines a map from property names to evaluation method.&#xD;
Keys are property names,&#xD;
values are sequences of functions to get property value starting from a $pdf object.&#xD;
</xqdoc:description></xqdoc:comment><xqdoc:annotations><xqdoc:annotation name="private"/></xqdoc:annotations><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>number-of-pages</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>number-of-bookmarks</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>number-of-labels</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>specification</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>getDocumentInformation</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocumentInformation</xqdoc:uri><xqdoc:name>getTitle</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>getDocumentInformation</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocumentInformation</xqdoc:uri><xqdoc:name>getAuthor</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>getDocumentInformation</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocumentInformation</xqdoc:uri><xqdoc:name>getCreator</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>getDocumentInformation</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocumentInformation</xqdoc:uri><xqdoc:name>getProducer</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>getDocumentInformation</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocumentInformation</xqdoc:uri><xqdoc:name>getSubject</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>getDocumentInformation</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocumentInformation</xqdoc:uri><xqdoc:name>getKeywords</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>getDocumentInformation</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocumentInformation</xqdoc:uri><xqdoc:name>getCreationDate</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>gregToISO</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>getDocumentInformation</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocumentInformation</xqdoc:uri><xqdoc:name>getModificationDate</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>gregToISO</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>labels-as-string</xqdoc:name></xqdoc:invoked><xqdoc:body>variable $pdfbox:property-map:=map{&#xD;
  "#pages": pdfbox:number-of-pages#1,&#xD;
&#xD;
  "#bookmarks": pdfbox:number-of-bookmarks#1,&#xD;
&#xD;
  "#labels": pdfbox:number-of-labels#1,&#xD;
&#xD;
  "specification":pdfbox:specification#1,&#xD;
&#xD;
  "title": (PDDocument:getDocumentInformation#1,&#xD;
            PDDocumentInformation:getTitle#1) ,&#xD;
&#xD;
  "author": (PDDocument:getDocumentInformation#1,&#xD;
             PDDocumentInformation:getAuthor#1 ),&#xD;
&#xD;
  "creator": (PDDocument:getDocumentInformation#1,&#xD;
              PDDocumentInformation:getCreator#1),&#xD;
&#xD;
  "producer": (PDDocument:getDocumentInformation#1,&#xD;
               PDDocumentInformation:getProducer#1),&#xD;
&#xD;
  "subject": (PDDocument:getDocumentInformation#1,&#xD;
              PDDocumentInformation:getSubject#1),&#xD;
&#xD;
  "keywords": (PDDocument:getDocumentInformation#1,&#xD;
               PDDocumentInformation:getKeywords#1),&#xD;
&#xD;
  "creationDate": (PDDocument:getDocumentInformation#1,&#xD;
                   PDDocumentInformation:getCreationDate#1,&#xD;
                   pdfbox:gregToISO#1),&#xD;
&#xD;
  "modificationDate":  (PDDocument:getDocumentInformation#1,&#xD;
                        PDDocumentInformation:getModificationDate#1,&#xD;
                        pdfbox:gregToISO#1),&#xD;
&#xD;
   "labels":      pdfbox:labels-as-string#1                     &#xD;
}</xqdoc:body></xqdoc:variable></xqdoc:variables><xqdoc:functions><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
"With-document" pattern: open pdf,apply $fn function, close pdf&#xD;
creates a local pdfobject and ensures it is closed after use&#xD;
e.g pdfbox:with-pdf("path...",pdfbox:page-text(?,5))&#xD;
</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:with-pdf</xqdoc:name><xqdoc:signature>function pdfbox:with-pdf ( $src as xs:string, $fn as function(item())as item()* ) as item()* { let $pdf:=pdfbox:open($src) return try{ $fn($pdf),pdfbox:close($pdf) } catch *{ pdfbox:close($pdf),fn:error($err:code,$src || " " || $err:description) } }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>src</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>fn</xqdoc:name><xqdoc:type>function(item())as item()*</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">item()</xqdoc:type></xqdoc:return><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>open</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>close</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>close</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>error</xqdoc:name></xqdoc:invoked><xqdoc:ref-variable><xqdoc:uri>http://www.w3.org/2005/xqt-errors</xqdoc:uri><xqdoc:name>code</xqdoc:name></xqdoc:ref-variable><xqdoc:ref-variable><xqdoc:uri>http://www.w3.org/2005/xqt-errors</xqdoc:uri><xqdoc:name>description</xqdoc:name></xqdoc:ref-variable><xqdoc:body>function pdfbox:with-pdf($src as xs:string,&#xD;
                                $fn as function(item())as item()*)&#xD;
as item()*{&#xD;
 let $pdf:=pdfbox:open($src)&#xD;
 return try{&#xD;
            $fn($pdf),pdfbox:close($pdf)&#xD;
        } catch *{&#xD;
            pdfbox:close($pdf),fn:error($err:code,$src || " " || $err:description)&#xD;
        }&#xD;
&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
open pdf using fetch:binary, returns pdf object</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:open</xqdoc:name><xqdoc:signature>function pdfbox:open ( $pdfsrc as item() ) as item() { pdfbox:open($pdfsrc, map{}) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdfsrc</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>item()</xqdoc:type></xqdoc:return><xqdoc:invoked arity="2"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>open</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:open($pdfsrc as item())&#xD;
as item(){&#xD;
pdfbox:open($pdfsrc, map{})&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
open pdf from file/url/binary, opts may have password , returns pdf object&#xD;
</xqdoc:description><xqdoc:param>$pdfsrc a fetchable url or filepath, or xs:base64Binary item</xqdoc:param><xqdoc:param>$opts options options include map {"password":}</xqdoc:param><xqdoc:custom tag="note">fetch:binary for https will use a lot of memory here</xqdoc:custom></xqdoc:comment><xqdoc:name>pdfbox:open</xqdoc:name><xqdoc:signature>function pdfbox:open ( $pdfsrc as item(), $opts as map(*) ) as item() { try{ if($pdfsrc instance of xs:base64Binary) then Loader:loadPDF( $pdfsrc,string($opts?password)) else if(starts-with($pdfsrc,"http")) then Loader:loadPDF( fetch:binary($pdfsrc),string($opts?password)) else Loader:loadPDF(RandomAccessReadBufferedFile:new($pdfsrc),string($opts?password)) } catch *{ let $loc:=if($pdfsrc instance of xs:base64Binary) then "xs:base64Binary" else $pdfsrc return error(xs:QName("pdfbox:open"),"Failed PDF load " || $loc || " " || $err:description) } }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdfsrc</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>opts</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>item()</xqdoc:type></xqdoc:return><xqdoc:invoked arity="2"><xqdoc:uri>java:org.apache.pdfbox.Loader</xqdoc:uri><xqdoc:name>loadPDF</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>string</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>starts-with</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>java:org.apache.pdfbox.Loader</xqdoc:uri><xqdoc:name>loadPDF</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://basex.org/modules/fetch</xqdoc:uri><xqdoc:name>binary</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>string</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>java:org.apache.pdfbox.Loader</xqdoc:uri><xqdoc:name>loadPDF</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.io.RandomAccessReadBufferedFile</xqdoc:uri><xqdoc:name>new</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>string</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>error</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2001/XMLSchema</xqdoc:uri><xqdoc:name>QName</xqdoc:name></xqdoc:invoked><xqdoc:ref-variable><xqdoc:uri>http://www.w3.org/2005/xqt-errors</xqdoc:uri><xqdoc:name>description</xqdoc:name></xqdoc:ref-variable><xqdoc:body>function pdfbox:open($pdfsrc as item(), $opts as map(*))&#xD;
as item(){&#xD;
  try{&#xD;
&#xD;
      if($pdfsrc instance of xs:base64Binary)&#xD;
      then Loader:loadPDF( $pdfsrc,string($opts?password))&#xD;
      else if(starts-with($pdfsrc,"http"))&#xD;
           then Loader:loadPDF( fetch:binary($pdfsrc),string($opts?password))&#xD;
           else  Loader:loadPDF(RandomAccessReadBufferedFile:new($pdfsrc),string($opts?password))&#xD;
&#xD;
} catch *{&#xD;
    let $loc:=if($pdfsrc instance of xs:base64Binary)&#xD;
              then "xs:base64Binary"&#xD;
              else $pdfsrc&#xD;
    return error(xs:QName("pdfbox:open"),"Failed PDF load " || $loc || " " || $err:description)&#xD;
}&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
The version of the PDF specification used by $pdf  e.g "1.4"&#xD;
returned as string to avoid float rounding issues&#xD;
</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:specification</xqdoc:name><xqdoc:signature>function pdfbox:specification ( $pdf as item() ) as xs:string { PDDocument:getVersion($pdf)=&gt;xs:decimal()=&gt;round(4)=&gt;string() }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>getVersion</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:specification($pdf as item())&#xD;
as xs:string{&#xD;
 PDDocument:getVersion($pdf)=&gt;xs:decimal()=&gt;round(4)=&gt;string()&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
Save pdf $pdf to filesystem at $savepath , returns $savepath</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:pdf-save</xqdoc:name><xqdoc:signature>function pdfbox:pdf-save ( $pdf as item(),$savepath as xs:string ) as xs:string { PDDocument:save($pdf, File:new($savepath)),$savepath }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>savepath</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return><xqdoc:invoked arity="2"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>save</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:java.io.File</xqdoc:uri><xqdoc:name>new</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:pdf-save($pdf as item(),$savepath as xs:string)&#xD;
as xs:string{&#xD;
   PDDocument:save($pdf, File:new($savepath)),$savepath&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
Create binary representation of $pdf object as xs:base64Binary</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:binary</xqdoc:name><xqdoc:signature>function pdfbox:binary ( $pdf as item() ) as xs:base64Binary { let $bytes:=Q{java:java.io.ByteArrayOutputStream}new() let $_:=PDDocument:save($pdf, $bytes) return Q{java:java.io.ByteArrayOutputStream}toByteArray($bytes) =&gt;convert:integers-to-base64() }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:base64Binary</xqdoc:type></xqdoc:return><xqdoc:invoked arity="0"><xqdoc:uri>java:java.io.ByteArrayOutputStream</xqdoc:uri><xqdoc:name>new</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>save</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:java.io.ByteArrayOutputStream</xqdoc:uri><xqdoc:name>toByteArray</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:binary($pdf as item())&#xD;
as xs:base64Binary{&#xD;
   let $bytes:=Q{java:java.io.ByteArrayOutputStream}new()&#xD;
   let $_:=PDDocument:save($pdf, $bytes)&#xD;
   return  Q{java:java.io.ByteArrayOutputStream}toByteArray($bytes)&#xD;
         =&gt;convert:integers-to-base64()&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
Release any resources related to $pdf</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:close</xqdoc:name><xqdoc:signature>function pdfbox:close ( $pdf as item() ) as empty-sequence() { (# db:wrapjava void #) { PDDocument:close($pdf) } }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>empty-sequence</xqdoc:type></xqdoc:return><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>close</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:close($pdf as item())&#xD;
as empty-sequence(){&#xD;
  (# db:wrapjava void #) {&#xD;
     PDDocument:close($pdf)&#xD;
  }&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
Number of pages in PDF</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:number-of-pages</xqdoc:name><xqdoc:signature>function pdfbox:number-of-pages ( $pdf as item() ) as xs:integer { PDDocument:getNumberOfPages($pdf) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:integer</xqdoc:type></xqdoc:return><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>getNumberOfPages</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:number-of-pages($pdf as item())&#xD;
as xs:integer{&#xD;
  PDDocument:getNumberOfPages($pdf)&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
Pdf page as image (zero is cover)&#xD;
options.format="bmp jpg png gif" etc, options.scale= 1 is 72 dpi??</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:page-render</xqdoc:name><xqdoc:signature>function pdfbox:page-render ( $pdf as item(),$pageNo as xs:integer,$options as map(*) ) as xs:base64Binary { let $options := map:merge(($options,map{"format":"jpg","scale":1})) let $bufferedImage := PDFRenderer:new($pdf) =&gt;PDFRenderer:renderImage($pageNo,$options?scale) let $bytes := Q{java:java.io.ByteArrayOutputStream}new() let $_ := Q{java:javax.imageio.ImageIO}write($bufferedImage ,$options?format, $bytes) return Q{java:java.io.ByteArrayOutputStream}toByteArray($bytes) =&gt;convert:integers-to-base64() }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>pageNo</xqdoc:name><xqdoc:type>xs:integer</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>options</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:base64Binary</xqdoc:type></xqdoc:return><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions/map</xqdoc:uri><xqdoc:name>merge</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.rendering.PDFRenderer</xqdoc:uri><xqdoc:name>new</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="0"><xqdoc:uri>java:java.io.ByteArrayOutputStream</xqdoc:uri><xqdoc:name>new</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="3"><xqdoc:uri>java:javax.imageio.ImageIO</xqdoc:uri><xqdoc:name>write</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:java.io.ByteArrayOutputStream</xqdoc:uri><xqdoc:name>toByteArray</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:page-render($pdf as item(),$pageNo as xs:integer,$options as map(*))&#xD;
as xs:base64Binary{&#xD;
  let $options := map:merge(($options,map{"format":"jpg","scale":1}))&#xD;
  let $bufferedImage := PDFRenderer:new($pdf)&#xD;
                      =&gt;PDFRenderer:renderImage($pageNo,$options?scale)&#xD;
  let $bytes := Q{java:java.io.ByteArrayOutputStream}new()&#xD;
  let $_ := Q{java:javax.imageio.ImageIO}write($bufferedImage ,$options?format,  $bytes)&#xD;
  return Q{java:java.io.ByteArrayOutputStream}toByteArray($bytes)&#xD;
         =&gt;convert:integers-to-base64()&#xD;
 &#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="0"><xqdoc:comment><xqdoc:description>&#xD;
Defined property names, sorted</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:property-names</xqdoc:name><xqdoc:signature>function pdfbox:property-names ( ) as xs:string* { $pdfbox:property-map=&gt;map:keys()=&gt;sort() }</xqdoc:signature><xqdoc:return><xqdoc:type occurrence="*">xs:string</xqdoc:type></xqdoc:return><xqdoc:ref-variable><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>property-map</xqdoc:name></xqdoc:ref-variable><xqdoc:body>function pdfbox:property-names() &#xD;
as xs:string*{&#xD;
  $pdfbox:property-map=&gt;map:keys()=&gt;sort()&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
Return the value of $property for $pdf</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:property</xqdoc:name><xqdoc:signature>function pdfbox:property ( $pdf as item(),$property as xs:string ) as item()* { let $fns:= $pdfbox:property-map($property) return if(exists($fns)) then fold-left($fns, $pdf, function($result,$this as function(*)){$result!$this(.)}) else error(xs:QName('pdfbox:property'),concat("Property '",$property,"' not defined.")) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>property</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">item()</xqdoc:type></xqdoc:return><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>exists</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="3"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>fold-left</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>error</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2001/XMLSchema</xqdoc:uri><xqdoc:name>QName</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="3"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>concat</xqdoc:name></xqdoc:invoked><xqdoc:ref-variable><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>property-map</xqdoc:name></xqdoc:ref-variable><xqdoc:body>function pdfbox:property($pdf as item(),$property as xs:string)&#xD;
as item()*{&#xD;
  let $fns:= $pdfbox:property-map($property)&#xD;
  return if(exists($fns))&#xD;
         then fold-left($fns, &#xD;
                        $pdf, &#xD;
                        function($result,$this as function(*)){$result!$this(.)})&#xD;
         else error(xs:QName('pdfbox:property'),concat("Property '",$property,"' not defined."))&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
summary CSV style info for all properties for $pdfpaths&#xD;
</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:report</xqdoc:name><xqdoc:signature>function pdfbox:report ( $pdfpaths as xs:string* ) as map(*) { pdfbox:report($pdfpaths,pdfbox:property-names()) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdfpaths</xqdoc:name><xqdoc:type occurrence="*">xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>map(*)</xqdoc:type></xqdoc:return><xqdoc:invoked arity="2"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>report</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="0"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>property-names</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:report($pdfpaths as xs:string*)&#xD;
as map(*){&#xD;
 pdfbox:report($pdfpaths,pdfbox:property-names())&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
summary CSV style info for named $properties for PDFs in $pdfpaths&#xD;
</xqdoc:description><xqdoc:see>https://docs.basex.org/main/CSV_Functions#xquery</xqdoc:see></xqdoc:comment><xqdoc:name>pdfbox:report</xqdoc:name><xqdoc:signature>function pdfbox:report ( $pdfpaths as item()*, $properties as xs:string* ) as map(*) { map{"names": array{"path",$properties}, "records": for $path in $pdfpaths let $name:=if($path instance of xs:base64Binary) then "binary" else $path return try{ let $pdf:=pdfbox:open($path) return (fold-left($properties, array{$name}, function($result as array(*),$prop as xs:string){ array:append($result, string(pdfbox:property($pdf, $prop)))} ), pdfbox:close($pdf) ) } catch *{ fold-left($properties, array{$name}, function($result as array(*),$prop as xs:string){ array:append($result, "#ERROR")} ) } } }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdfpaths</xqdoc:name><xqdoc:type occurrence="*">item()</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>properties</xqdoc:name><xqdoc:type occurrence="*">xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>map(*)</xqdoc:type></xqdoc:return><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>open</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="3"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>fold-left</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>http://www.w3.org/2005/xpath-functions/array</xqdoc:uri><xqdoc:name>append</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>string</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>property</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>close</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="3"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>fold-left</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>http://www.w3.org/2005/xpath-functions/array</xqdoc:uri><xqdoc:name>append</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:report($pdfpaths as item()*, $properties as xs:string*)&#xD;
as map(*){&#xD;
  map{"names":   array{"path",$properties},&#xD;
  &#xD;
      "records": for $path in $pdfpaths&#xD;
                 let $name:=if($path instance of xs:base64Binary) then "binary" else $path&#xD;
                 return try{&#xD;
                  let $pdf:=pdfbox:open($path)&#xD;
                  return (fold-left($properties,&#xD;
                                  array{$name},&#xD;
                                  function($result as array(*),$prop as xs:string){&#xD;
                                    array:append($result, string(pdfbox:property($pdf, $prop)))}&#xD;
                         ), pdfbox:close($pdf)&#xD;
                         )&#xD;
                 } catch *{&#xD;
                      fold-left($properties,&#xD;
                                array{$name},&#xD;
                                function($result as array(*),$prop as xs:string){&#xD;
                                    array:append($result, "#ERROR")}&#xD;
                               )&#xD;
                 }&#xD;
               &#xD;
  }&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
Convenience function to save report() data to file</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:report-save</xqdoc:name><xqdoc:signature>function pdfbox:report-save ( $data as map(*),$dest as xs:string ) as empty-sequence() { let $opts := map { "format":"xquery", "header":"yes", "separator" : "," } return file:write-text($dest,csv:serialize($data,$opts)) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>data</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>dest</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>empty-sequence</xqdoc:type></xqdoc:return><xqdoc:invoked arity="2"><xqdoc:uri>http://expath.org/ns/file</xqdoc:uri><xqdoc:name>write-text</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>http://basex.org/modules/csv</xqdoc:uri><xqdoc:name>serialize</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:report-save($data as map(*),$dest as xs:string)&#xD;
as empty-sequence(){&#xD;
  let $opts := map {  "format":"xquery", "header":"yes", "separator" : "," }&#xD;
  return file:write-text($dest,csv:serialize($data,$opts))&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
The number of outline items defined in $pdf</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:number-of-bookmarks</xqdoc:name><xqdoc:signature>function pdfbox:number-of-bookmarks ( $pdf as item() ) as xs:integer { let $xml:=pdfbox:outline-xml($pdf) return count($xml//bookmark) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:integer</xqdoc:type></xqdoc:return><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>outline-xml</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>count</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:number-of-bookmarks($pdf as item())&#xD;
as xs:integer{&#xD;
  let $xml:=pdfbox:outline-xml($pdf)&#xD;
  return count($xml//bookmark)&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
XMP metadata as "RDF" document&#xD;
</xqdoc:description><xqdoc:custom tag="note">usually rdf:RDF root, but sometimes x:xmpmeta</xqdoc:custom></xqdoc:comment><xqdoc:name>pdfbox:metadata</xqdoc:name><xqdoc:signature>function pdfbox:metadata ( $pdf as item() ) as document-node(element(*))? { let $m:=PDDocument:getDocumentCatalog($pdf) =&gt;PDDocumentCatalog:getMetadata() return if(exists($m)) then let $is:=PDMetadata:exportXMPMetadata($m) return pdfbox:do-until( map{"n":0,"data":""}, function($input,$pos ) { pdfbox:read-stream($is,$input?data)}, function($output,$pos) { $output?n eq -1 } )?data=&gt;parse-xml() else () }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="?">document-node(element(*))</xqdoc:type></xqdoc:return><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>getDocumentCatalog</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>exists</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.common.PDMetadata</xqdoc:uri><xqdoc:name>exportXMPMetadata</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="3"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>do-until</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>read-stream</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:metadata($pdf as item())&#xD;
as document-node(element(*))?&#xD;
{&#xD;
  let $m:=PDDocument:getDocumentCatalog($pdf)&#xD;
         =&gt;PDDocumentCatalog:getMetadata()&#xD;
  return  if(exists($m))&#xD;
          then &#xD;
              let $is:=PDMetadata:exportXMPMetadata($m)&#xD;
              return pdfbox:do-until(&#xD;
                        map{"n":0,"data":""},&#xD;
&#xD;
                        function($input,$pos ) {  pdfbox:read-stream($is,$input?data)},&#xD;
&#xD;
                        function($output,$pos) { $output?n eq -1 }     &#xD;
                     )?data=&gt;parse-xml()&#xD;
          else ()&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
read next block from XMP stream</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:read-stream</xqdoc:name><xqdoc:annotations><xqdoc:annotation name="private"/></xqdoc:annotations><xqdoc:signature>function pdfbox:read-stream ( $is,$read as xs:string ) as map(*) { let $blen:=4096 let $buff:=Q{java:java.util.Arrays}copyOf(array{xs:byte(0)},$blen) let $n:= COSInputStream:read($is,$buff,xs:int(0),xs:int($blen)) let $data:=convert:integers-to-base64(subsequence($buff,1,$n))=&gt;convert:binary-to-string() return map{"n":$n, "data": $read || $data} }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>is</xqdoc:name></xqdoc:parameter><xqdoc:parameter><xqdoc:name>read</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>map(*)</xqdoc:type></xqdoc:return><xqdoc:invoked arity="2"><xqdoc:uri>java:java.util.Arrays</xqdoc:uri><xqdoc:name>copyOf</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2001/XMLSchema</xqdoc:uri><xqdoc:name>byte</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="4"><xqdoc:uri>java:org.apache.pdfbox.cos.COSInputStream</xqdoc:uri><xqdoc:name>read</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2001/XMLSchema</xqdoc:uri><xqdoc:name>int</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2001/XMLSchema</xqdoc:uri><xqdoc:name>int</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://basex.org/modules/convert</xqdoc:uri><xqdoc:name>integers-to-base64</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="3"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>subsequence</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:read-stream($is,$read as xs:string)&#xD;
as map(*){&#xD;
  let $blen:=4096&#xD;
  let $buff:=Q{java:java.util.Arrays}copyOf(array{xs:byte(0)},$blen)&#xD;
  let $n:= COSInputStream:read($is,$buff,xs:int(0),xs:int($blen))&#xD;
  let $data:=convert:integers-to-base64(subsequence($buff,1,$n))=&gt;convert:binary-to-string()&#xD;
  return map{"n":$n, "data": $read || $data}&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
Return outline for $pdf as map()*</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:outline</xqdoc:name><xqdoc:signature>function pdfbox:outline ( $pdf as item() ) as map(*)* { (# db:wrapjava some #) { let $outline:= PDDocument:getDocumentCatalog($pdf) =&gt;PDDocumentCatalog:getDocumentOutline() return if(exists($outline)) then pdfbox:outline($pdf,PDOutlineItem:getFirstChild($outline)) } }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">map(*)</xqdoc:type></xqdoc:return><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>getDocumentCatalog</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>exists</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>outline</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem</xqdoc:uri><xqdoc:name>getFirstChild</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:outline($pdf as item())&#xD;
as map(*)*{&#xD;
  (# db:wrapjava some #) {&#xD;
  let $outline:=&#xD;
                PDDocument:getDocumentCatalog($pdf)&#xD;
                =&gt;PDDocumentCatalog:getDocumentOutline()&#xD;
 &#xD;
  return  if(exists($outline))&#xD;
          then pdfbox:outline($pdf,PDOutlineItem:getFirstChild($outline)) &#xD;
  }&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
return bookmark info for children of $outlineItem as seq of maps</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:outline</xqdoc:name><xqdoc:annotations><xqdoc:annotation name="private"/></xqdoc:annotations><xqdoc:signature>function pdfbox:outline ( $pdf as item(),$outlineItem as item()? ) as map(*)* { let $find as map(*):=pdfbox:outline_($pdf ,$outlineItem) return map:get($find,"list") }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>outlineItem</xqdoc:name><xqdoc:type occurrence="?">item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">map(*)</xqdoc:type></xqdoc:return><xqdoc:invoked arity="2"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>outline_</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>http://www.w3.org/2005/xpath-functions/map</xqdoc:uri><xqdoc:name>get</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:outline($pdf as item(),$outlineItem as item()?)&#xD;
as map(*)*{&#xD;
  let $find as map(*):=pdfbox:outline_($pdf ,$outlineItem)&#xD;
  return map:get($find,"list")&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
outline helper. BaseX bug 10.7? error if inlined in outline</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:outline_</xqdoc:name><xqdoc:annotations><xqdoc:annotation name="private"/></xqdoc:annotations><xqdoc:signature>function pdfbox:outline_ ( $pdf as item(),$outlineItem as item()? ) as map(*) { pdfbox:do-until( map{"list":(),"this":$outlineItem}, function($input,$pos ) { let $bk:= pdfbox:bookmark($input?this,$pdf) let $bk:= if($bk?hasChildren) then let $kids:=pdfbox:outline($pdf,PDOutlineItem:getFirstChild($input?this)) return map:merge(($bk,map:entry("children",$kids))) else $bk return map{ "list": ($input?list, $bk), "this": PDOutlineItem:getNextSibling($input?this)} }, function($output,$pos) { empty($output?this) } ) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>outlineItem</xqdoc:name><xqdoc:type occurrence="?">item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>map(*)</xqdoc:type></xqdoc:return><xqdoc:invoked arity="3"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>do-until</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>bookmark</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>outline</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem</xqdoc:uri><xqdoc:name>getFirstChild</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions/map</xqdoc:uri><xqdoc:name>merge</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>http://www.w3.org/2005/xpath-functions/map</xqdoc:uri><xqdoc:name>entry</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem</xqdoc:uri><xqdoc:name>getNextSibling</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>empty</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:outline_($pdf as item(),$outlineItem as item()?)&#xD;
as map(*){&#xD;
  pdfbox:do-until(&#xD;
    &#xD;
     map{"list":(),"this":$outlineItem},&#xD;
&#xD;
     function($input,$pos ) { &#xD;
        let $bk:= pdfbox:bookmark($input?this,$pdf)&#xD;
        let $bk:= if($bk?hasChildren)&#xD;
                  then let $kids:=pdfbox:outline($pdf,PDOutlineItem:getFirstChild($input?this))&#xD;
                        return map:merge(($bk,map:entry("children",$kids)))&#xD;
                  else $bk &#xD;
        return map{&#xD;
              "list": ($input?list, $bk),&#xD;
              "this":  PDOutlineItem:getNextSibling($input?this)}&#xD;
      },&#xD;
&#xD;
     function($output,$pos) { empty($output?this) }                      &#xD;
  )&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
PDF outline in xml format</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:outline-xml</xqdoc:name><xqdoc:signature>function pdfbox:outline-xml ( $pdf as item() ) as element(outline)? { let $outline:=pdfbox:outline($pdf) return if(exists($outline)) then &lt;outline&gt;{$outline!pdfbox:bookmark-xml(.)}&lt;/outline&gt; else () }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="?">element(outline)</xqdoc:type></xqdoc:return><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>outline</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>exists</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>bookmark-xml</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:outline-xml($pdf as item())&#xD;
as element(outline)?{&#xD;
 let $outline:=pdfbox:outline($pdf)&#xD;
  return if(exists($outline))&#xD;
         then &lt;outline&gt;{$outline!pdfbox:bookmark-xml(.)}&lt;/outline&gt;&#xD;
         else ()&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
Convert outline map to XML</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:bookmark-xml</xqdoc:name><xqdoc:annotations><xqdoc:annotation name="private"/></xqdoc:annotations><xqdoc:signature>function pdfbox:bookmark-xml ( $outline as map(*)* ) as element(bookmark)* { $outline! &lt;bookmark title="{?title}" index="{?index}"&gt; {?children!pdfbox:bookmark-xml(.)} &lt;/bookmark&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>outline</xqdoc:name><xqdoc:type occurrence="*">map(*)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">element(bookmark)</xqdoc:type></xqdoc:return><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>bookmark-xml</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:bookmark-xml($outline as map(*)*)&#xD;
as element(bookmark)*&#xD;
{&#xD;
  $outline!&#xD;
  &lt;bookmark title="{?title}" index="{?index}"&gt;&#xD;
    {?children!pdfbox:bookmark-xml(.)}&#xD;
  &lt;/bookmark&gt;&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
Return bookmark info for $bookmark&#xD;
</xqdoc:description><xqdoc:return>map{index:..,title:..,hasChildren:..}</xqdoc:return></xqdoc:comment><xqdoc:name>pdfbox:bookmark</xqdoc:name><xqdoc:annotations><xqdoc:annotation name="private"/></xqdoc:annotations><xqdoc:signature>function pdfbox:bookmark ( $bookmark as item(),$pdf as item() ) as map(*) { map{ "index": PDOutlineItem:findDestinationPage($bookmark,$pdf)=&gt;pdfbox:find-page($pdf), "title": (# db:checkstrings #) {PDOutlineItem:getTitle($bookmark)} (:=&gt;translate("ï¿½",""), :), "hasChildren": PDOutlineItem:hasChildren($bookmark) } }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>bookmark</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>map(*)</xqdoc:type></xqdoc:return><xqdoc:invoked arity="2"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem</xqdoc:uri><xqdoc:name>findDestinationPage</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem</xqdoc:uri><xqdoc:name>getTitle</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.interactive.documentnavigation.outline.PDOutlineItem</xqdoc:uri><xqdoc:name>hasChildren</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:bookmark($bookmark as item(),$pdf as item())&#xD;
as map(*)&#xD;
{&#xD;
 map{ &#xD;
  "index":  PDOutlineItem:findDestinationPage($bookmark,$pdf)=&gt;pdfbox:find-page($pdf),&#xD;
  "title":  (# db:checkstrings #) {PDOutlineItem:getTitle($bookmark)}&#xD;
  (:=&gt;translate("ï¿½",""), :),&#xD;
  "hasChildren": PDOutlineItem:hasChildren($bookmark)&#xD;
  }&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
pageIndex of $page in $pdf</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:find-page</xqdoc:name><xqdoc:signature>function pdfbox:find-page ( $page as item()? (: as java:org.apache.pdfbox.pdmodel.PDPage :), $pdf as item() ) as item()? { if(exists($page)) then PDDocument:getDocumentCatalog($pdf) =&gt;PDDocumentCatalog:getPages() =&gt;PDPageTree:indexOf($page) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>page</xqdoc:name><xqdoc:type occurrence="?">item()</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="?">item()</xqdoc:type></xqdoc:return><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>exists</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>getDocumentCatalog</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:find-page(&#xD;
   $page as item()? (: as java:org.apache.pdfbox.pdmodel.PDPage :),&#xD;
   $pdf as item())&#xD;
as item()?&#xD;
{&#xD;
  if(exists($page))&#xD;
  then PDDocument:getDocumentCatalog($pdf)&#xD;
      =&gt;PDDocumentCatalog:getPages()&#xD;
      =&gt;PDPageTree:indexOf($page)&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
Return new  PDF doc with pages from $start to $end as xs:base64Binary, (1 based)&#xD;
</xqdoc:description><xqdoc:param>$start first page to include</xqdoc:param><xqdoc:param>$end last page to include</xqdoc:param></xqdoc:comment><xqdoc:name>pdfbox:extract-range</xqdoc:name><xqdoc:signature>function pdfbox:extract-range ( $pdf as item(), $start as xs:integer,$end as xs:integer ) as xs:base64Binary { let $a:=PageExtractor:new($pdf, $start, $end) =&gt;PageExtractor:extract() return (pdfbox:binary($a),pdfbox:close($a)) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>start</xqdoc:name><xqdoc:type>xs:integer</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>end</xqdoc:name><xqdoc:type>xs:integer</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:base64Binary</xqdoc:type></xqdoc:return><xqdoc:invoked arity="3"><xqdoc:uri>java:org.apache.pdfbox.multipdf.PageExtractor</xqdoc:uri><xqdoc:name>new</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>binary</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>close</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:extract-range($pdf as item(), &#xD;
             $start as xs:integer,$end as xs:integer)&#xD;
as xs:base64Binary&#xD;
{&#xD;
    let $a:=PageExtractor:new($pdf, $start, $end) =&gt;PageExtractor:extract()&#xD;
    return (pdfbox:binary($a),pdfbox:close($a)) &#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
The number of labels defined in PDF</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:number-of-labels</xqdoc:name><xqdoc:signature>function pdfbox:number-of-labels ( $pdf as item() ) as xs:integer { let $labels:=PDDocument:getDocumentCatalog($pdf) =&gt;PDDocumentCatalog:getPageLabels() return if(exists($labels)) then PDPageLabels:getPageRangeCount($labels) else 0 }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:integer</xqdoc:type></xqdoc:return><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>getDocumentCatalog</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>exists</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.common.PDPageLabels</xqdoc:uri><xqdoc:name>getPageRangeCount</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:number-of-labels($pdf as item())&#xD;
as xs:integer&#xD;
{&#xD;
  let $labels:=PDDocument:getDocumentCatalog($pdf)&#xD;
               =&gt;PDDocumentCatalog:getPageLabels()&#xD;
  return if(exists($labels)) &#xD;
         then PDPageLabels:getPageRangeCount($labels)&#xD;
         else 0&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
pageLabel for every page from derived from page-ranges&#xD;
The returned sequence will contain at MOST as much entries as the document has pages.&#xD;
</xqdoc:description><xqdoc:see>https://www.w3.org/TR/WCAG20-TECHS/PDF17.html#PDF17-examples</xqdoc:see><xqdoc:see>https://codereview.stackexchange.com/questions/286078/java-code-showing-page-labels-from-pdf-files</xqdoc:see></xqdoc:comment><xqdoc:name>pdfbox:labels-by-page</xqdoc:name><xqdoc:signature>function pdfbox:labels-by-page ( $pdf as item() ) as xs:string* { PDDocument:getDocumentCatalog($pdf) =&gt;PDDocumentCatalog:getPageLabels() =&gt;PDPageLabels:getLabelsByPageIndices() }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">xs:string</xqdoc:type></xqdoc:return><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>getDocumentCatalog</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:labels-by-page($pdf as item())&#xD;
as xs:string*&#xD;
{&#xD;
  PDDocument:getDocumentCatalog($pdf)&#xD;
  =&gt;PDDocumentCatalog:getPageLabels()&#xD;
  =&gt;PDPageLabels:getLabelsByPageIndices()&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
sequence of label ranges defined in PDF as formatted strings&#xD;
</xqdoc:description><xqdoc:return>a custom representation of the labels e.g "0-*Cover,1r,11D"</xqdoc:return></xqdoc:comment><xqdoc:name>pdfbox:labels-as-string</xqdoc:name><xqdoc:signature>function pdfbox:labels-as-string ( $pdf as item() ) as xs:string { let $pagelabels:=PDDocument:getDocumentCatalog($pdf) =&gt;PDDocumentCatalog:getPageLabels() return $pagelabels !(0 to pdfbox:number-of-pages($pdf)-1) !pdfbox:label-as-string($pagelabels,.)=&gt;string-join("&amp;#10;") }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>getDocumentCatalog</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>number-of-pages</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>label-as-string</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:labels-as-string($pdf as item())&#xD;
as xs:string{&#xD;
  let $pagelabels:=PDDocument:getDocumentCatalog($pdf)&#xD;
                   =&gt;PDDocumentCatalog:getPageLabels()&#xD;
  return $pagelabels&#xD;
         !(0 to pdfbox:number-of-pages($pdf)-1)&#xD;
         !pdfbox:label-as-string($pagelabels,.)=&gt;string-join("&amp;#10;")&#xD;
            &#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
get pagelabels exist</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:page-labels</xqdoc:name><xqdoc:signature>function pdfbox:page-labels ( $pdf ) { PDDocument:getDocumentCatalog($pdf) =&gt;PDDocumentCatalog:getPageLabels() }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name></xqdoc:parameter></xqdoc:parameters><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>getDocumentCatalog</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:page-labels($pdf)&#xD;
{&#xD;
  PDDocument:getDocumentCatalog($pdf)&#xD;
  =&gt;PDDocumentCatalog:getPageLabels()&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
label for $page formated as string, empty if none</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:label-as-string</xqdoc:name><xqdoc:signature>function pdfbox:label-as-string ( $pagelabels,$page as xs:integer ) as xs:string? { let $label:=PDPageLabels:getPageLabelRange($pagelabels,$page) return if(empty($label)) then () else let $start:= PDPageLabelRange:getStart($label) let $style := PDPageLabelRange:getStyle($label) let $prefix:= PDPageLabelRange:getPrefix($label) return string-join(($page, if(empty($style)) then "-" else $style, if(($start eq 1)) then "" else $start, if(exists($prefix)) then '*' || $prefix (:TODO double " :) )) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pagelabels</xqdoc:name></xqdoc:parameter><xqdoc:parameter><xqdoc:name>page</xqdoc:name><xqdoc:type>xs:integer</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="?">xs:string</xqdoc:type></xqdoc:return><xqdoc:invoked arity="2"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.common.PDPageLabels</xqdoc:uri><xqdoc:name>getPageLabelRange</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>empty</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.common.PDPageLabelRange</xqdoc:uri><xqdoc:name>getStart</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.common.PDPageLabelRange</xqdoc:uri><xqdoc:name>getStyle</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.common.PDPageLabelRange</xqdoc:uri><xqdoc:name>getPrefix</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>string-join</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>empty</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>exists</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:label-as-string($pagelabels,$page as  xs:integer)&#xD;
as xs:string?{&#xD;
  let $label:=PDPageLabels:getPageLabelRange($pagelabels,$page)&#xD;
  return  if(empty($label))&#xD;
          then ()&#xD;
          else&#xD;
            let $start:=  PDPageLabelRange:getStart($label)&#xD;
            let $style := PDPageLabelRange:getStyle($label)&#xD;
            let $prefix:= PDPageLabelRange:getPrefix($label) &#xD;
            return string-join(($page, &#xD;
                                if(empty($style)) then "-" else $style,&#xD;
                                if(($start eq 1)) then "" else $start,&#xD;
                                if(exists($prefix)) then '*' || $prefix  (:TODO double " :)&#xD;
                    ))&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
sequence of maps for each label/page range defined in $pdf</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:labels-as-map</xqdoc:name><xqdoc:signature>function pdfbox:labels-as-map ( $pdf as item() ) as map(*)* { let $pagelabels:=PDDocument:getDocumentCatalog($pdf) =&gt;PDDocumentCatalog:getPageLabels() return $pagelabels !(0 to pdfbox:number-of-pages($pdf)-1) !pdfbox:label-as-map($pagelabels,.) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">map(*)</xqdoc:type></xqdoc:return><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>getDocumentCatalog</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>number-of-pages</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>org.expkg_zone58.Pdfbox3</xqdoc:uri><xqdoc:name>label-as-map</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:labels-as-map($pdf as item())&#xD;
as map(*)*{&#xD;
  let $pagelabels:=PDDocument:getDocumentCatalog($pdf)&#xD;
                   =&gt;PDDocumentCatalog:getPageLabels()&#xD;
  return  $pagelabels&#xD;
          !(0 to pdfbox:number-of-pages($pdf)-1)&#xD;
          !pdfbox:label-as-map($pagelabels,.)&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
label/page-range for $page as map</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:label-as-map</xqdoc:name><xqdoc:signature>function pdfbox:label-as-map ( $pagelabels,$page as xs:integer ) as map(*) { let $label:=PDPageLabels:getPageLabelRange($pagelabels,$page) return if(empty($label)) then () else map{ "index": $page, "prefix": PDPageLabelRange:getPrefix($label), "start": PDPageLabelRange:getStart($label), "style": PDPageLabelRange:getStyle($label) } }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pagelabels</xqdoc:name></xqdoc:parameter><xqdoc:parameter><xqdoc:name>page</xqdoc:name><xqdoc:type>xs:integer</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>map(*)</xqdoc:type></xqdoc:return><xqdoc:invoked arity="2"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.common.PDPageLabels</xqdoc:uri><xqdoc:name>getPageLabelRange</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>empty</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.common.PDPageLabelRange</xqdoc:uri><xqdoc:name>getPrefix</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.common.PDPageLabelRange</xqdoc:uri><xqdoc:name>getStart</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.common.PDPageLabelRange</xqdoc:uri><xqdoc:name>getStyle</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:label-as-map($pagelabels,$page as  xs:integer)&#xD;
as map(*)&#xD;
{&#xD;
  let $label:=PDPageLabels:getPageLabelRange($pagelabels,$page)&#xD;
  return if(empty($label))&#xD;
  then ()&#xD;
  else map{&#xD;
      "index": $page,&#xD;
      "prefix": PDPageLabelRange:getPrefix($label),&#xD;
      "start":  PDPageLabelRange:getStart($label),&#xD;
      "style":  PDPageLabelRange:getStyle($label)&#xD;
      }&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
return text on $pageNo</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:page-text</xqdoc:name><xqdoc:signature>function pdfbox:page-text ( $pdf as item(), $pageNo as xs:integer ) as xs:string { let $tStripper := (# db:wrapjava instance #) { PDFTextStripper:new() =&gt; PDFTextStripper:setStartPage($pageNo) =&gt; PDFTextStripper:setEndPage($pageNo) } return (# db:checkstrings #) {PDFTextStripper:getText($tStripper,$pdf)} }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>pageNo</xqdoc:name><xqdoc:type>xs:integer</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return><xqdoc:invoked arity="0"><xqdoc:uri>java:org.apache.pdfbox.text.PDFTextStripper</xqdoc:uri><xqdoc:name>new</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>java:org.apache.pdfbox.text.PDFTextStripper</xqdoc:uri><xqdoc:name>getText</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:page-text($pdf as item(), $pageNo as xs:integer)&#xD;
as xs:string{&#xD;
  let $tStripper := (# db:wrapjava instance #) {&#xD;
         PDFTextStripper:new()&#xD;
         =&gt; PDFTextStripper:setStartPage($pageNo)&#xD;
         =&gt; PDFTextStripper:setEndPage($pageNo)&#xD;
       }&#xD;
  return (# db:checkstrings #) {PDFTextStripper:getText($tStripper,$pdf)}&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
Return size of $pageNo (zero based)&#xD;
</xqdoc:description><xqdoc:return>e.g. [0.0,0.0,168.0,239.52]</xqdoc:return></xqdoc:comment><xqdoc:name>pdfbox:page-media-box</xqdoc:name><xqdoc:signature>function pdfbox:page-media-box ( $pdf as item(), $pageNo as xs:integer ) as xs:string { PDDocument:getPage($pdf, $pageNo) =&gt;PDPage:getMediaBox() =&gt;PDRectangle:toString() }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pdf</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>pageNo</xqdoc:name><xqdoc:type>xs:integer</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return><xqdoc:invoked arity="2"><xqdoc:uri>java:org.apache.pdfbox.pdmodel.PDDocument</xqdoc:uri><xqdoc:name>getPage</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:page-media-box($pdf as item(), $pageNo as xs:integer)&#xD;
as xs:string{&#xD;
  PDDocument:getPage($pdf, $pageNo)&#xD;
  =&gt;PDPage:getMediaBox()&#xD;
  =&gt;PDRectangle:toString()&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="0"><xqdoc:comment><xqdoc:description>&#xD;
Version of Apache Pdfbox in use  e.g. "3.0.4"</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:version</xqdoc:name><xqdoc:signature>function pdfbox:version ( ) as xs:string { Q{java:org.apache.pdfbox.util.Version}getVersion() }</xqdoc:signature><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return><xqdoc:invoked arity="0"><xqdoc:uri>java:org.apache.pdfbox.util.Version</xqdoc:uri><xqdoc:name>getVersion</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:version()&#xD;
as xs:string{&#xD;
  Q{java:org.apache.pdfbox.util.Version}getVersion()&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
Convert date</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:gregToISO</xqdoc:name><xqdoc:annotations><xqdoc:annotation name="private"/></xqdoc:annotations><xqdoc:signature>function pdfbox:gregToISO ( $item as item()? ) as xs:string? { if(exists($item)) then Q{java:java.util.GregorianCalendar}toZonedDateTime($item)=&gt;string() else () }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>item</xqdoc:name><xqdoc:type occurrence="?">item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="?">xs:string</xqdoc:type></xqdoc:return><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>exists</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>java:java.util.GregorianCalendar</xqdoc:uri><xqdoc:name>toZonedDateTime</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:gregToISO($item as item()?)&#xD;
as xs:string?{&#xD;
 if(exists($item))&#xD;
 then Q{java:java.util.GregorianCalendar}toZonedDateTime($item)=&gt;string()&#xD;
 else ()&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
fn:do-until shim for BaseX 9+10&#xD;
if  fn:do-until not found use hof:until, note: $pos always zero&#xD;
</xqdoc:description></xqdoc:comment><xqdoc:name>pdfbox:do-until</xqdoc:name><xqdoc:annotations><xqdoc:annotation name="private"/></xqdoc:annotations><xqdoc:signature>function pdfbox:do-until ( $input as item()*, $action as function(item()*, xs:integer) as item()*, $predicate as function(item()*, xs:integer) as xs:boolean? ) as item()* { let $fn:=function-lookup(QName('http://www.w3.org/2005/xpath-functions','do-until'), 3) return if(exists($fn)) then $fn($input,$action,$predicate) else let $hof:=function-lookup(QName('http://basex.org/modules/hof','until'), 3) return if(exists($hof)) then $hof($predicate(?,0),$action(?,0),$input) else error(xs:QName('pdfbox:do-until'),"No implementation do-until found") }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>input</xqdoc:name><xqdoc:type occurrence="*">item()</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>action</xqdoc:name><xqdoc:type>function(item()*, xs:integer) as item()*</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>predicate</xqdoc:name><xqdoc:type>function(item()*, xs:integer) as xs:boolean?</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">item()</xqdoc:type></xqdoc:return><xqdoc:invoked arity="2"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>function-lookup</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>QName</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>exists</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>function-lookup</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>QName</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>exists</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="2"><xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri><xqdoc:name>error</xqdoc:name></xqdoc:invoked><xqdoc:invoked arity="1"><xqdoc:uri>http://www.w3.org/2001/XMLSchema</xqdoc:uri><xqdoc:name>QName</xqdoc:name></xqdoc:invoked><xqdoc:body>function pdfbox:do-until(&#xD;
 $input 	as item()*, 	&#xD;
 $action 	as function(item()*, xs:integer) as item()*, 	&#xD;
 $predicate 	as function(item()*, xs:integer) as xs:boolean? 	&#xD;
) as item()*&#xD;
{&#xD;
  let $fn:=function-lookup(QName('http://www.w3.org/2005/xpath-functions','do-until'), 3)&#xD;
  return if(exists($fn))&#xD;
         then $fn($input,$action,$predicate)&#xD;
         else let $hof:=function-lookup(QName('http://basex.org/modules/hof','until'), 3)&#xD;
              return if(exists($hof))&#xD;
                      then $hof($predicate(?,0),$action(?,0),$input)&#xD;
                      else error(xs:QName('pdfbox:do-until'),"No implementation do-until found")&#xD;
&#xD;
}</xqdoc:body></xqdoc:function></xqdoc:functions></xqdoc:xqdoc>